use std::cmp::min;

impl Solution {
    pub fn probability_of_heads(mut prob: Vec<f64>, mut target: i32) -> f64 {
        let n = prob.len();
        if n == 0 {
            return 0f64;
        }
        if n == 1 {
            return prob[0];
        }
        prob = prob.into_iter().filter(|&v| {
            if v < 1e-8 {
                return false;
            }
            if (v - 1f64).abs() < 1e-8 {
                target -= 1;
                false
            } else {
                true
            }
        }).collect();
        if target < 0 {
            return 0f64;
        }
        let n = prob.len();
        if target > n as i32 {
            return 0f64;
        }
        if n == 0 {
            return 1f64;
        }
        let ut = target as usize;
        let mut f = vec![0f64; ut+1];
        f[0] = 1f64-prob[0];
        if ut > 0 {
            f[1] = prob[0];
        }
        for i in 1..n {
            for j in (0..=min(i+1, ut)).rev() {
                let mut t = 0f64;
                t += f[j] * (1f64 - prob[i]);
                if j > 0 {
                    t += f[j-1] * prob[i];
                }
                f[j] = t;
            }
        }
        f[ut]
    }
}

struct Solution;

#[cfg(test)]
mod tests {
    use super::Solution;

    #[test]
    fn test_probability_of_heads() {
        let test_cases = vec![
            (vec![0.5,0.5,0.5,0.5,0.5], 0, 0.03125),
            //(vec![0.9135438348889597,0.32438744165539823,0.3868611933705496,0.9871121517253313,0.09876739266164869,0.1443522802956042,0.36162923554484294,0.6625872890913753,0.7826203138601814,0.27460883851315077,0.0032965431253674238,0.20822264152047376,0.19226105170629393,0.5639344311603798,0.2972082333499191,0.5024344238740126,0.1748125690469985,0.9641662772141751,0.32122352918324826,0.43529740104197534,0.5365465795338453,0.022881507698555237,0.4403400288378785,0.7887241769379247,0.6841994114410378,0.5410197916638442,0.8435323044055282,0.5682015425887841,0.9542534697622123,0.7372109882486253,0.5767792642354487,0.5712965511660671,0.8010670548393382,0.10550245120448154,0.9647938104297391,0.8119337146186432,0.001070320111662415,0.31975631674912397,0.33185215202024,0.8648259771487887,0.6592673996678542,0.11958621417008775,0.7295758694130468,0.2537713308195283,0.9417398388593169,0.44601282409929444,0.09970204232987012,0.7117427834472995,0.9281519408437229,0.7410007371056517,0.783763537966945,0.5100673889668227,0.7569196957956575,0.355640102104542,0.6854589122508691,0.7804638061407695,0.7409801306882831,0.06155252397030986,0.14568508148689985,0.0028871028144576982,0.19508544891238533,0.6341913755379488,0.611090472424578,0.9046797084674008,0.2585105113473303,0.4551543672890449,0.1187490161123419,0.23954009457175562,0.5308796769996138,0.06184192885793793,0.39464643444056313,0.5510736261148111,0.3527016007995526,0.43310801296447854,0.3175735942391257,0.8179754068928008,0.21909530705032698,0.2301247199771207,0.03711193562270021,0.5467088198874193,0.1328453462441761,0.6050096392123816,0.37128354139226405,0.7245535158042276,0.2991323895380733,0.04087053641416394,0.6044643217575758,0.28813809967037207,0.8694022588280925,0.39691825395708047,0.664329117337648,0.07188593182268466,0.3487204145258268,0.7457688755192893,0.6427635194325466,0.10914963693801716,0.3418842753071749,0.7617045846251943,0.5020736817356659,0.1283435618952854], 8, 0.8),
            (vec![0.2,0.8,0f64,0.3,0.5], 3, 0.182),
            (vec![0.4f64], 1, 0.4f64),
            (vec![1.0,1.0,1.0,1.0,1.0,1.0], 6, 1f64),
            (vec![1.0,1.0,1.0,1.0,1.0,1.0], 5, 0f64),
            (vec![0.5, 0.5], 2, 0.25),
            (vec![0.5, 0.5], 1, 0.5),
            (vec![0.5, 0.6], 1, 0.5),
        ];
        for (prob, target, expect) in test_cases {
            let actual = Solution::probability_of_heads(prob.clone(), target);
            assert!((actual-expect).abs() < 1e-5, "prob: {:?}, target: {}, actual: {}", prob, target, actual);
        }
    }
}